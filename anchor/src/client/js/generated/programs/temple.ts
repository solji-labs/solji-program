/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from 'gill';
import {
  type ParsedBurnIncenseInstruction,
  type ParsedBuyIncenseInstruction,
  type ParsedCreateNftMintInstruction,
  type ParsedCreateTempleConfigInstruction,
  type ParsedCreateWishInstruction,
  type ParsedDonateInstruction,
  type ParsedDrawFortuneInstruction,
  type ParsedInitUserInstruction,
  type ParsedLikeWishInstruction,
  type ParsedMintBuddhaNftInstruction,
  type ParsedUpdateDonationLevelsInstruction,
  type ParsedUpdateFortuneConfigInstruction,
  type ParsedUpdateIncenseTypesInstruction,
} from '../instructions';

export const TEMPLE_PROGRAM_ADDRESS =
  '5iZVCAG6GAq3wdVL31Hy2eTybnUEYkgvnamqdQETAPUK' as Address<'5iZVCAG6GAq3wdVL31Hy2eTybnUEYkgvnamqdQETAPUK'>;

export enum TempleAccount {
  BuddhaNFT,
  TempleConfig,
  UserState,
  Wish,
}

export function identifyTempleAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): TempleAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([42, 248, 94, 111, 99, 57, 196, 133])
      ),
      0
    )
  ) {
    return TempleAccount.BuddhaNFT;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([27, 116, 7, 67, 209, 48, 108, 209])
      ),
      0
    )
  ) {
    return TempleAccount.TempleConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([72, 177, 85, 249, 76, 167, 186, 126])
      ),
      0
    )
  ) {
    return TempleAccount.UserState;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([19, 93, 74, 238, 190, 158, 94, 132])
      ),
      0
    )
  ) {
    return TempleAccount.Wish;
  }
  throw new Error(
    'The provided account could not be identified as a temple account.'
  );
}

export enum TempleInstruction {
  BurnIncense,
  BuyIncense,
  CreateNftMint,
  CreateTempleConfig,
  CreateWish,
  Donate,
  DrawFortune,
  InitUser,
  LikeWish,
  MintBuddhaNft,
  UpdateDonationLevels,
  UpdateFortuneConfig,
  UpdateIncenseTypes,
}

export function identifyTempleInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): TempleInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([192, 206, 18, 53, 21, 1, 239, 134])
      ),
      0
    )
  ) {
    return TempleInstruction.BurnIncense;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([158, 244, 18, 199, 55, 137, 6, 154])
      ),
      0
    )
  ) {
    return TempleInstruction.BuyIncense;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([220, 240, 28, 248, 182, 238, 138, 21])
      ),
      0
    )
  ) {
    return TempleInstruction.CreateNftMint;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([227, 91, 153, 89, 83, 215, 178, 242])
      ),
      0
    )
  ) {
    return TempleInstruction.CreateTempleConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([47, 64, 159, 45, 95, 19, 61, 165])
      ),
      0
    )
  ) {
    return TempleInstruction.CreateWish;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([121, 186, 218, 211, 73, 70, 196, 180])
      ),
      0
    )
  ) {
    return TempleInstruction.Donate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([167, 57, 67, 163, 76, 93, 229, 97])
      ),
      0
    )
  ) {
    return TempleInstruction.DrawFortune;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([14, 51, 68, 159, 237, 78, 158, 102])
      ),
      0
    )
  ) {
    return TempleInstruction.InitUser;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([237, 115, 19, 77, 234, 31, 168, 83])
      ),
      0
    )
  ) {
    return TempleInstruction.LikeWish;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([104, 31, 241, 122, 252, 250, 253, 0])
      ),
      0
    )
  ) {
    return TempleInstruction.MintBuddhaNft;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([96, 131, 75, 121, 196, 186, 118, 117])
      ),
      0
    )
  ) {
    return TempleInstruction.UpdateDonationLevels;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([103, 193, 204, 242, 205, 62, 148, 221])
      ),
      0
    )
  ) {
    return TempleInstruction.UpdateFortuneConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([36, 90, 39, 8, 76, 221, 92, 131])
      ),
      0
    )
  ) {
    return TempleInstruction.UpdateIncenseTypes;
  }
  throw new Error(
    'The provided instruction could not be identified as a temple instruction.'
  );
}

export type ParsedTempleInstruction<
  TProgram extends string = '5iZVCAG6GAq3wdVL31Hy2eTybnUEYkgvnamqdQETAPUK',
> =
  | ({
      instructionType: TempleInstruction.BurnIncense;
    } & ParsedBurnIncenseInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.BuyIncense;
    } & ParsedBuyIncenseInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.CreateNftMint;
    } & ParsedCreateNftMintInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.CreateTempleConfig;
    } & ParsedCreateTempleConfigInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.CreateWish;
    } & ParsedCreateWishInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.Donate;
    } & ParsedDonateInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.DrawFortune;
    } & ParsedDrawFortuneInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.InitUser;
    } & ParsedInitUserInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.LikeWish;
    } & ParsedLikeWishInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.MintBuddhaNft;
    } & ParsedMintBuddhaNftInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.UpdateDonationLevels;
    } & ParsedUpdateDonationLevelsInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.UpdateFortuneConfig;
    } & ParsedUpdateFortuneConfigInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.UpdateIncenseTypes;
    } & ParsedUpdateIncenseTypesInstruction<TProgram>);
